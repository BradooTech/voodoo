#!/usr/bin/env python
# coding: utf-8

from inspect import getdoc
import sys
import socket
import logging
from string import Template
from subprocess import check_call
import os
import yaml

from compose.cli.main import TopLevelCommand, setup_logging, parse_doc_section
from compose.cli.errors import UserError
from compose.project import NoSuchService, ConfigurationError
from compose.cli.docopt_command import NoSuchCommand
from docker.errors import APIError
from compose.service import BuildError

log = logging.getLogger(__name__)

TEMPLATE = "https://github.com/akretion/voodoo.git"
ODOO_GIT = "https://github.com/OCA/OCB.git"

# inspired from http://stackoverflow.com
# /questions/8100166/inheriting-methods-docstrings-in-python
def fix_docs(cls):
    for name, func in vars(cls).items():
        if not func.__doc__:
            for parent in cls.__bases__:
                if hasattr(parent, name):
                    parfunc = getattr(parent, name)
                    if parfunc and getattr(parfunc, '__doc__', None):
                        func.__doc__ = parfunc.__doc__.replace(
                            'docker-compose', 'voodoo')
                        break
    return cls


def is_open(port):
     sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     result = sock.connect_ex(('127.0.0.1', port))
     if result == 0:
        return True
     else:
        return False



@fix_docs
class VoodooCommand(TopLevelCommand):
    """Fast, isolated development environments using Docker.

    Usage:
      voodoo [options] [COMMAND] [ARGS...]
      voodoo -h|--help

    Options:
      --verbose                 Show more output
      --version                 Print version and exit
      -f, --file FILE           Specify an alternate compose file
                                (default: voodoo.yml)
      -p, --project-name NAME   Specify an alternate project name
                                (default: directory name)

    Commands:
      build     Build or rebuild services
      help      Get help on a command
      kill      Kill containers
      logs      View output from containers
      port      Print the public port for a port binding
      ps        List containers
      pull      Pulls service images
      rm        Remove stopped containers
      run       Run a one-off command
      scale     Set number of containers for a service
      start     Start services
      stop      Stop services
      restart   Restart services
      up        Create and start containers

    """

    def __init__(self, *args, **kwargs):
        self.home = os.path.expanduser("~")
        self.shared_folder = os.path.join(self.home, '.voodoo', 'shared')
        config_path = os.path.join(self.home, '.voodoo', 'config.yml')
        if not os.path.isfile(config_path):
            os.makedirs(self.shared_folder)
            conf_file = open(config_path, 'w')
            conf_file.write('\n'.join(
                "shared_eggs: True",
                "shared_odoo: False",
                ))
            log.info("Create default config file at %s" % config_file)
        conf_file = open(config_path, 'r')
        conf = yaml.load(conf_file)
        self.shared_eggs = conf.get('shared_eggs', True)
        self.shared_odoo = conf.get('shared_odoo', False)

        #TODO FIXME
        try:
            file = open('voodoo.yml')
            s = Template(file.read())
            vals = self.get_keyvalue()
            res = s.substitute(vals)
            output = open('.voodoo.yml', 'w')
            output.write(res)
        except:
            pass

        return super(VoodooCommand, self).__init__(*args, **kwargs)

    def clone_odoo(self, ref_path, dest_path):
        # TODO to improve the speed of initial config
        # We may implement latter a caching system
        # The idea will to have an existing copy of the repo
        # and just mv it here
        # and an new copy of repo while be the generated in background
        log.info("Start cloning odoo from local odoo")
        check_call(["git", "clone", "file://%s" % ref_path, dest_path])

    def get_odoo(self, odoo_path):
        odoo_ref_path = os.path.join(self.shared_folder, 'odoo')
        if not os.path.exists(odoo_ref_path):
            log.info(
                "First run of voodoo, there is no odoo repo in %s. "
                "Start to download odoo from github this can take a while...\n"
                "If you have an existing Odoo repo (from OCA) you can stop it "
                "and copy paste you repo in %s", odoo_ref_path, odoo_ref_path)
            check_call(["git", "clone", ODOO_GIT, odoo_ref_path])
        if self.shared_odoo:
            shared_odoo_path = os.path.join(
                self.shared_folder,
                'shared_odoo',
                self.shared_odoo,
                )
            if not os.path.exists(shared_odoo_path):
                log.info(
                    "Shared odoo is activated, but there is no shared "
                    "repository in %s",  shared_odoo_path)
                self.clone_odoo(odoo_ref_path, shared_odoo_path)
            log.info("Create symlink from %s to %s",
                     shared_odoo_path, odoo_path)
            check_call(['ln', '-s', shared_odoo_path, odoo_path])
        else:
            self.clone_odoo(odoo_ref_path, odoo_path)

    def run(self, project, options):
        if not options.get('SERVICE'):
            options['SERVICE'] = 'odoo'
        if not options.get('--service-ports'):
            options['--service-ports'] = True
        if not options.get('COMMAND'):
            options['COMMAND'] = 'bash'
        odoo_path = os.path.join('parts', 'odoo')
        if not os.path.exists(odoo_path):
            self.get_odoo(odoo_path)
        return super(VoodooCommand, self).run(project, options)

    def get_keyvalue(self):
        return {
            'odoo_port': 8069,
            'odoo_polling_port': 8072,
        }

    def get_config_path(self, file_path=None):
        if not file_path:
            file_path = '.voodoo.yml'
        return super(VoodooCommand, self).get_config_path(file_path=file_path)

    def get_config(self, config_path):
        config = super(VoodooCommand, self).get_config(config_path)
        home = os.path.expanduser("~")
        shared = os.path.join(home, '.voodoo', 'shared')
        config['odoo']['volumes'].append('%s:%s' % (shared, shared))
        config['odoo']['environment'] += [
            'SHARED_FOLDER=%s' % shared,
            'SHARED_EGGS=%s' % str(self.shared_eggs).lower(),
            ]
        return config

    def new(self, project, options):
        """
        Start a new project
        Usage: new [options] PROJECT
        """
        check_call(["git", "clone", TEMPLATE, options['PROJECT']])

    def open(self, project, options):
        """
        Open an new terminal in voodoo
        Usage: open
        """
        container = project.containers(service_names=['odoo'], one_off=True)
        if container:
            check_call(["docker", "exec", "-ti", container[0].name, "bash"])
        else:
            log.error("No container found for the service odoo "
                      "in the project %s" % project.name)

    def perform_command(self, options, handler, command_options):
        # no need of project params for new method
        if options['COMMAND'] == 'new':
            # Skip looking up the compose file.
            handler(None, command_options)
            return
        return super(VoodooCommand, self).perform_command(
            options, handler, command_options)

    def dispatch(self, *args, **kwargs):
        # Inject default value for run method
        if args and args[0] and args[0][0] == 'run' and len(args[0]) == 1:
            args[0].append('odoo')
        return super(VoodooCommand, self).dispatch(
            *args, **kwargs)

def main():
    setup_logging()
    try:
        command = VoodooCommand()
        command.sys_dispatch()
    except KeyboardInterrupt:
        log.error("\nAborting.")
        sys.exit(1)
    except (UserError, NoSuchService, ConfigurationError) as e:
        log.error(e.msg)
        sys.exit(1)
    except NoSuchCommand as e:
        log.error("No such command: %s", e.command)
        log.error("")
        log.error("\n".join(
            parse_doc_section("commands:", getdoc(e.supercommand))))
        sys.exit(1)
    except APIError as e:
        log.error(e.explanation)
        sys.exit(1)
    except BuildError as e:
        log.error("Service '%s' failed to build: %s"
                  % (e.service.name, e.reason))
        sys.exit(1)

main()
